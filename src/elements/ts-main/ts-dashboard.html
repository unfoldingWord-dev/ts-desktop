
<link rel="import" href="../../components/neon-animation/neon-animation.html">
<link rel="import" href="../../components/iron-signals/iron-signals.html">
<link rel="import" href="../../components/paper-dialog/paper-dialog.html">

<link rel="import" href="./ts-app-titlebar.html">
<link rel="import" href="../ts-profile/ts-profile.html">
<link rel="import" href="../ts-home/ts-home.html">
<link rel="import" href="../ts-new/ts-new.html">
<link rel="import" href="../ts-review/ts-review.html">
<link rel="import" href="../ts-translate/ts-translate.html">
<link rel="import" href="../ts-settings/ts-settings.html">
<link rel="import" href="../ts-updates/ts-updates.html">
<link rel="import" href="../ts-print/ts-print.html">
<link rel="import" href="../ts-dialogs/ts-repo-search.html">
<link rel="import" href="../ts-dialogs/ts-import-options.html">
<link rel="import" href="../ts-dialogs/ts-feedback.html">
<link rel="import" href="../ts-dialogs/ts-loading.html">
<link rel="import" href="../ts-dialogs/ts-export-options.html">
<link rel="import" href="../ts-dialogs/ts-update-options.html">
<link rel="import" href="../ts-dialogs/ts-print-options.html">
<link rel="import" href="../ts-dialogs/ts-conflict.html">
<link rel="import" href="../ts-dialogs/ts-import-confirm.html">
<link rel="import" href="../ts-dialogs/ts-container-confirm.html">
<link rel="import" href="../ts-legal/ts-terms.html">
<link rel="import" href="../ts-legal/ts-license.html">
<link rel="import" href="../ts-legal/ts-statement.html">
<link rel="import" href="../ts-legal/ts-guidelines.html">
<link rel="import" href="../ts-legal/ts-software.html">
<link rel="import" href="../ts-legal/ts-attribution.html">

<dom-module id="ts-dashboard">

  <style>

      :host {
          display: flex;
          flex-direction: column;
          flex: auto;
      }

      neon-animated-pages {
          flex: auto;
          display: flex;
      }

      neon-animated-pages > * {
          flex: auto;
      }

      #statusbar {
          width: 100%;
          background: var(--primary-color-dark);
          color: var(--reverse-text-color);
          min-height: 30px;
          padding: 0 20px;
          font-size: 75%;
          display: flex;
          align-items: center;
      }

      #message {
          padding-left: 10px;
      }

      .popup {
          position: fixed;
          top: 0;
          bottom: 0;
          left: 0;
          right: 0;
          margin: auto;
      }

      .popup * {
          margin: 0;
          padding: 0;
      }

      .legal {
          width: 95%;
          height: 95%;
          overflow-y: auto;
      }

      #feedback {
          width: 500px;
          height: 330px;
      }

      #import {
          width: 320px;
          height: 440px;
      }

      #export {
          width: 320px;
          height: 440px;
      }

      #update {
          width: 480px;
          height: 480px;
      }

      #repo {
          width: 500px;
          height: 500px;
      }

      #loading {
          width: 320px;
          height: 220px;
      }

      #wideloading {
          width: 450px;
          height: 220px;
      }

      #print {
          width: 450px;
          height: 330px;
      }

      #conflict {
          width: 450px;
          height: 200px;
      }

      #importconfirm {
          width: 450px;
          height: 210px;
      }

      #containerconfirm {
          width: 450px;
          height: 175px;
      }

      .hide {
          display: none;
      }

      @media print {
          #statusbar {
              display: none;
          }
          ts-app-titlebar {
              display: none;
          }
      }

  </style>

  <template>

      <ts-app-titlebar currentuser="[[currentuser]]"></ts-app-titlebar>
      <neon-animated-pages attr-for-selected="data-route" selected="{{route}}">
          <ts-home data-route="home" route="{{route}}" currentproject="{{currentproject}}" projectlist="{{projectlist}}" importdata="{{importdata}}" id="home"></ts-home>
          <ts-new data-route="new" route="{{route}}" importdata="{{importdata}}" projectlist="[[projectlist]]" currentuser="[[currentuser]]" options="{{options}}" on-finishusfm="confirmUsfmImport"></ts-new>
          <ts-translate data-route="translate" route="{{route}}" message="{{message}}" projectlist="[[projectlist]]" currentproject="{{currentproject}}" currentuser="[[currentuser]]" options="{{options}}" id="translate" on-update="updateFromProject" on-exportusfm="exportUsfm" on-openprint="openPrint"></ts-translate>
          <ts-review data-route="review" route="{{route}}" currentproject="{{currentproject}}" currentuser="[[currentuser]]" options="{{options}}"></ts-review>
          <ts-settings data-route="settings" route="{{route}}" currentproject="[[currentproject]]" options="{{options}}" id="settings"></ts-settings>
          <ts-profile data-route="profile" currentuser="[[currentuser]]" options="{{options}}"></ts-profile>
          <ts-print data-route="preview" route="{{route}}" currentproject="[[currentproject]]" options="{{options}}" id="preview"></ts-print>
          <ts-updates data-route="updates" route="{{route}}" options="{{options}}"></ts-updates>
          <ts-terms data-route="terms"></ts-terms>
      </neon-animated-pages>
      <div id="statusbar">
          <span>Status: </span><span id="message">{{message}}</span>
      </div>

      <paper-dialog id="print" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-print-options id="printoptions" currentproject="{{currentproject}}" options="{{options}}" on-openpreview="openPreview"></ts-print-options>
      </paper-dialog>

      <paper-dialog id="feedback" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-feedback feedback="{{feedback}}" email="{{feedbackEmail}}" include-logs="{{feedbackIncludeLogs}}" on-close="closeFeedback" on-send="sendFeedback"></ts-feedback>
      </paper-dialog>

      <paper-dialog id="import" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-import-options on-project="startProjectImport" on-usfm="startUsfmImport" on-repo="openRepoImport" on-container="startContainerImport"></ts-import-options>
      </paper-dialog>

      <paper-dialog id="repo" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-repo-search id="reposearch" importdata="{{importdata}}" on-cancel="cancelRepo" on-startrepoimport="startRepoImport"></ts-repo-search>
      </paper-dialog>

      <paper-dialog id="loading" class="popup" modal="true" exit-animation="scale-down-animation">
          <ts-loading options="[[options]]"></ts-loading>
      </paper-dialog>

      <paper-dialog id="wideloading" class="popup" modal="true" exit-animation="scale-down-animation">
          <ts-loading options="[[options]]"></ts-loading>
      </paper-dialog>

      <paper-dialog id="export" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-export-options on-project="exportProject" on-upload="uploadProject" on-checkprint="checkPrint" on-checkusfm="checkUsfm" currentproject="[[currentproject]]"></ts-export-options>
      </paper-dialog>

      <paper-dialog id="update" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-update-options on-language="updateLanguageList" on-source="updateSourceList" on-download="downloadSources"></ts-update-options>
      </paper-dialog>

      <paper-dialog id="license" class="popup legal" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-license></ts-license>
      </paper-dialog>

      <paper-dialog id="guidelines" class="popup legal" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-guidelines></ts-guidelines>
      </paper-dialog>

      <paper-dialog id="statement" class="popup legal" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-statement></ts-statement>
      </paper-dialog>

      <paper-dialog id="software" class="popup legal" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-software></ts-software>
      </paper-dialog>

      <paper-dialog id="attribution" class="popup legal" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-attribution></ts-attribution>
      </paper-dialog>

      <paper-dialog id="conflict" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-conflict currentproject="[[currentproject]]" importdata="{{importdata}}" currentuser="[[currentuser]]" on-startrepoimport="startRepoImport"></ts-conflict>
      </paper-dialog>

      <paper-dialog id="importconfirm" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-import-confirm importdata="{{importdata}}" on-cancel="clearTempDir" on-finishimport="finishImport"></ts-import-confirm>
      </paper-dialog>

      <paper-dialog id="confirmimportusfm" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-import-confirm importdata="{{importdata}}" on-cancel="clearTempDir" on-finishimport="finishUsfmImport"></ts-import-confirm>
      </paper-dialog>

      <paper-dialog id="containerconfirm" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
          <ts-container-confirm on-finish="finishContainerImport"></ts-container-confirm>
      </paper-dialog>

      <iron-signals on-iron-signal-openfeedback="openFeedback"></iron-signals>
      <iron-signals on-iron-signal-openimport="openImport"></iron-signals>
      <iron-signals on-iron-signal-openexport="openExport"></iron-signals>
      <iron-signals on-iron-signal-updateuser="updateUser"></iron-signals>
      <iron-signals on-iron-signal-openlicense="openLicense"></iron-signals>
      <iron-signals on-iron-signal-openguidelines="openGuidelines"></iron-signals>
      <iron-signals on-iron-signal-openstatement="openStatement"></iron-signals>
      <iron-signals on-iron-signal-opensoftware="openSoftware"></iron-signals>
      <iron-signals on-iron-signal-openattribution="openAttribution"></iron-signals>
      <iron-signals on-iron-signal-changeproject="changeProject"></iron-signals>
      <iron-signals on-iron-signal-deleteproject="deleteProject"></iron-signals>
      <iron-signals on-iron-signal-openupdate="openUpdate"></iron-signals>
      <iron-signals on-iron-signal-openloading="openLoading"></iron-signals>
      <iron-signals on-iron-signal-closeloading="closeLoading"></iron-signals>
      <iron-signals on-iron-signal-updatesourcelist="updateSourceList"></iron-signals>

  </template>

</dom-module>

<script>

  Polymer({
      is: 'ts-dashboard',

      properties: {
          route: {
              type: String,
              value: ''
          },
          projectlist: {
              type: Array,
              value: []
          },
          currentproject: {
              type: Object,
              value: {}
          },
          feedback: {
              type: String,
              value: ""
          },
          feedbackEmail: {
              type: String,
              value: ""
          },
          feedbackIncludeLogs: {
              type: Boolean,
              value: true
          },
          currentuser: {
              type: Object,
              value: {}
          },
          importdata: {
              type: Object,
              value: {}
          },
          options: {
              type: Object,
              value: {}
          },
          message: {
              type: String,
              value: "Idle"
          }
      },

      openLicense: function () {
          var legal = this.$.license;
          legal.open();
          setTimeout(function () {
              legal.scrollTop = 0;
          }, 250);
      },

      openGuidelines: function () {
          var legal = this.$.guidelines;
          legal.open();
          setTimeout(function () {
              legal.scrollTop = 0;
          }, 250);
      },

      openStatement: function () {
          var legal = this.$.statement;
          legal.open();
          setTimeout(function () {
              legal.scrollTop = 0;
          }, 250);
      },

      openSoftware: function () {
          var legal = this.$.software;
          legal.open();
          setTimeout(function () {
              legal.scrollTop = 0;
          }, 250);
      },

      openAttribution: function () {
          var legal = this.$.attribution;
          legal.open();
          setTimeout(function () {
              legal.scrollTop = 0;
          }, 250);
      },

      updateUser: function (event, data) {
          App.configurator.setValue("userdata", data);
          this.checkUser(data);
      },

      checkUser: function (user) {
          this.set('currentuser', user);
          if (user.full_name) {
              if (user.accepted) {
                  this.set('route', 'home');
              } else {
                  this.set('route', 'terms');
              }
          } else {
              this.set('route', 'profile');
          }
      },

      openLoading: function () {
          this.$.loading.open();
      },

      closeLoading: function () {
          this.$.loading.close();
      },

      showLoadingMessage: function (msg) {
          this.set('options', {});
          this.set('options.body', msg);
          this.set('options.loading', true);
          this.openLoading();
      },

      showMessage: function (title, body) {
          this.set('options', {});
          this.set('options.title', title);
          this.set('options.body', body);
          this.set('options.loading', false);
          this.$.wideloading.close();
          this.openLoading();
      },

      showErrorMessage: function (title, defaultBody, err) {
          App.reporter.logError(err, title, 1);

          this.showMessage(title, defaultBody);
      },

      showConflictsMessage: function (title, body, conflicts) {
          var msg = body;

          if (conflicts && conflicts.length) {
              App.reporter.logNotice(conflicts, 'Chunk Conflicts');
              if (conflicts.length === 1) {
                  msg += ' There is ' + conflicts.length + ' chunk that contains a new conflict that needs your attention.';
              } else {
                  msg += ' There are ' + conflicts.length + ' chunks that contain new conflicts that need your attention.';
              }
          }

          this.showMessage(title, msg);
      },

      openUpdate: function () {
          this.$.update.open();
      },

      updateLanguageList: function () {
          var mythis = this;
          var before = App.dataManager.getMetrics();

          var onProgress = function (type, total, complete) {
              if (complete === 7000) {
                  mythis.set('options.value', 66);
              }
          };

          mythis.$.update.close();
          mythis.showLoadingMessage('Updating List of Target Languages. This may take a while. Please wait...');
          mythis.set('options.progress', true);
          mythis.set('options.value', 33);

          setTimeout(function () {
              return App.dataManager.updateLanguages(onProgress)
                  .then(function () {
                      var after = App.dataManager.getMetrics();
                      var diff = after.target_language_count - before.target_language_count;
                      var msg = diff + ' Target Languages have been added.';
                      if (diff < 1) {
                          msg = 'No Target Languages have been added.';
                      }
                      if (diff === 1) {
                          msg = '1 Target Language has been added.';
                      }
                      mythis.showMessage('Update Complete', msg);
                  })
                  .catch(function (err) {
                      var errmessage = 'An error occurred while updating';
                      if (err.syscall === "getaddrinfo") {
                          errmessage = "Unable to connect to server";
                      }
                      if (err.syscall === "read") {
                          errmessage = "Lost connection to server";
                      }
                      mythis.showErrorMessage('Update Failed', errmessage, err);
                  });
          }, 500);
      },

      updateSourceList: function () {
          var mythis = this;
          var before = App.dataManager.getMetrics();
          var end = false;

          var onProgress = function (type, total, complete) {
              var value = 0;

              if (type === "projects") {
                  value = Math.round(complete / total * 10);
              } else if (type === "resources") {
                  value = Math.round(complete / total * 88) + 10;
                  end = true;
              } else if (end) {
                  value = 99;
              }
              mythis.set('options.value', value);
          };

          mythis.$.update.close();
          mythis.showLoadingMessage('Updating List of Source Texts. This may take a while. Please wait...');
          mythis.set('options.progress', true);
          mythis.set('options.value', 0);

          setTimeout(function () {
              return App.dataManager.updateSources(onProgress)
                  .then(function () {
                      var after = App.dataManager.getMetrics();
                      var diff = after.resource_count_level3 - before.resource_count_level3;
                      var msg = diff + ' new Source Texts are available to be downloaded.';
                      if (diff < 1) {
                          msg = 'No new Source Texts have been added.';
                      }
                      if (diff === 1) {
                          msg = '1 new Source Text is available to be downloaded.';
                      }
                      mythis.set('route', 'updates');
                      mythis.showMessage('Update Complete', msg);
                  })
                  .catch(function (err) {
                      var errmessage = 'An error occurred while updating';
                      if (err.syscall === "getaddrinfo") {
                          errmessage = "Unable to connect to server";
                      }
                      if (err.syscall === "read") {
                          errmessage = "Lost connection to server";
                      }
                      mythis.showErrorMessage('Update Failed', errmessage, err);
                  });
          }, 500);
      },

      downloadSources: function () {
          var mythis = this;

          mythis.$.update.close();
          mythis.showLoadingMessage('Loading source texts. Please wait...');

          setTimeout(function() {
              mythis.set('route', 'updates');
          }, 500);
      },

      deleteProject: function (event, data) {
          var mythis = this;
          var projectmeta = data.projectmeta;

          mythis.showLoadingMessage('Deleting project.  Please wait...');

          setTimeout(function() {
              return App.projectsManager.deleteTargetTranslation(projectmeta)
                  .then(function() {
                      App.projectsManager.unsetValues(projectmeta.unique_id);

                      var list = mythis.projectlist;
                      var newlist = list.filter(function (item) {
                          return item.unique_id !== projectmeta.unique_id;
                      });

                      return mythis.sortProjects(newlist);
                  })
                  .then(function () {
                      mythis.showMessage('Project Deleted', 'Your project has been successfully deleted.');
                  })
                  .catch(function(err) {
                      mythis.showErrorMessage('Delete Failed', 'An error occurred while trying to delete your project', err);
                  });
          }, 500);
      },

      changeProject: function (event, data) {
          var mythis = this;
          var conflicts = [];
          var changedata = data;
          var newmanifest = changedata.newmeta;

          mythis.set('route', 'home');
          mythis.showLoadingMessage('Changing project.  Please wait...');

          setTimeout(function () {
              return Promise.resolve(true)
                  .then(function () {
                      if (changedata.exists) {
                          return App.gitManager.merge(mythis.currentuser, changedata.newpaths.projectDir, changedata.oldpaths.projectDir)
                              .then(function (data) {
                                  conflicts = data.conflicts;
                                  newmanifest = data.manifest;
                                  return Promise.resolve(true);
                              })
                              .then(function () {
                                  return App.utils.fs.remove(changedata.oldpaths.projectDir);
                              });
                      } else {
                          return App.utils.fs.mover(changedata.oldpaths.projectDir, changedata.newpaths.projectDir)
                              .then(function () {
                                  return App.projectsManager.saveTargetManifest(changedata.newmeta);
                              })
                              .then(function () {
                                  return App.projectsManager.commitProject(changedata.newmeta, mythis.currentuser);
                              });
                      }
                  })
                  .then(function () {
                      App.projectsManager.unsetValues(changedata.oldmeta.unique_id);

                      var list = mythis.projectlist;
                      var newlist = list.filter(function (item) {
                          return item.unique_id !== changedata.oldmeta.unique_id && item.unique_id !== changedata.newmeta.unique_id;
                      });

                      newlist.push(App.projectsManager.updateManifestToMeta(newmanifest));

                      return mythis.sortProjects(newlist);
                  })
                  .then(function () {
                      mythis.showConflictsMessage('Change Complete', 'Your project has been changed.', conflicts);
                  })
                  .catch(function(err) {
                      mythis.showErrorMessage('Change Failed', 'An error occurred while trying to change the project', err);
                  });
          }, 500);
      },

      openImport: function () {
          this.$.import.open();
      },

      openRepoImport: function () {
          var mythis = this;

          this.$.import.close();
          this.set('importdata', {username: this.currentuser.username, project: ""});
          this.$.repo.open();

          setTimeout(function() {
              mythis.$.reposearch.searchRepos();
          }, 500);
      },

      cancelRepo: function () {
          this.$.repo.close();
          this.openImport();
      },

      startRepoImport: function () {
          var mythis = this;
          var path = require('path');
          var repo = this.importdata.repo.repo;
          var project = this.importdata.repo.project;
          var force = this.importdata.force || false;
          var server = App.configurator.getUserSetting('dataserver');
          var repourl = server.replace(/\/+$/, '') + "/" + repo;
          var targetDir = App.configurator.getValue('targetTranslationsDir');
          var tmpDir = App.configurator.getValue('tempDir');
          var targetPath = path.join(targetDir, project);
          var tmpPath = path.join(tmpDir, project);

          mythis.$.repo.close();
          if (mythis.route !== "home") {
              mythis.set('route', 'home');
              mythis.$.translate.reset();
          }
          mythis.showLoadingMessage("Importing. Please wait...");

          setTimeout(function() {
              return App.utils.fs.mkdirs(tmpPath)
                  .then(function () {
                      return App.gitManager.clone(repourl, tmpDir)
                  })
                  .then(function () {
                      var paths = App.utils.makeProjectPaths(tmpDir, project);
                      return App.migrateManager.migrate(paths);
                  })
                  .then(function (data) {
                      project = data.paths.projectDir.split(path.sep).pop();
                      targetPath = path.join(targetDir, project);
                      tmpPath = path.join(tmpDir, project);
                      mythis.set('importdata.targetpath', targetPath);
                      mythis.set('importdata.tmppath', tmpPath);
                      return App.utils.fs.stat(targetPath).then(App.utils.ret(true)).catch(App.utils.ret(false));
                  })
                  .then(function (exists) {
                      if (force) {
                          mythis.set('importdata.overwrite', false);
                          return mythis.finishImport();
                      } else if (exists) {
                          mythis.closeLoading();
                          mythis.$.importconfirm.open();
                      } else {
                          mythis.set('importdata.overwrite', true);
                          return mythis.finishImport();
                      }
                  })
                  .catch(function(err) {
                      mythis.showErrorMessage("Import Failed", "An error occurred while importing your project", err && err.error ? err.error : err);

                      return mythis.clearTempDir();
                  });
          }, 500);
      },

      startProjectImport: function() {
          var mythis = this;
          var defaultPath = App.configurator.getUserPath('datalocation', 'backups');
          var filePath = App.ipc.sendSync('open-file', {options: {defaultPath: defaultPath, filters: [{name: 'Tstudio Files', extensions: ['tstudio']}], properties: ['openFile']}});
          if (!filePath) {
              return;
          }

          mythis.$.import.close();
          mythis.showLoadingMessage('Importing. Please wait...');

          setTimeout(function() {
              return App.importManager.extractBackup(filePath[0])
                  .then(function (list) {
                      return Promise.all(list.map(function (item) {
                          mythis.set('importdata', {targetpath: item.targetPath, tmppath: item.tmpPath});
                          if (item.targetExists) {
                              mythis.closeLoading();
                              mythis.$.importconfirm.open();
                          } else {
                              mythis.set('importdata.overwrite', true);
                              return mythis.finishImport();
                          }
                      }))
                  })
                  .catch(function(err) {
                      var errmessage = 'An error occurred while importing your project';

                      if (err.includes("Error while extracting file")) {
                          errmessage = err;
                      }

                      mythis.showErrorMessage('Import Failed', errmessage, err);

                      return mythis.clearTempDir();
                  });
          }, 500);
      },

      finishImport: function () {
          var mythis = this;
          var path = require('path');
          var conflicts = [];
          var overwrite = this.importdata.overwrite;
          var targetPath = this.importdata.targetpath;
          var tmpPath = this.importdata.tmppath;
          var key = targetPath.split(path.sep).pop();
          var newmanifest = {};

          mythis.showLoadingMessage("Importing. Please wait...");

          setTimeout(function() {
              return Promise.resolve(true)
                  .then(function () {
                      if (overwrite) {
                          App.projectsManager.unsetValues(key);
                          return App.utils.fs.mover(tmpPath, targetPath)
                              .then(function () {
                                  return App.projectsManager.retrieveManifest(targetPath);
                              })
                              .then(function (manifest) {
                                  newmanifest = manifest;
                                  return Promise.resolve(true);
                              });
                      } else {
                          return App.gitManager.merge(mythis.currentuser, targetPath, tmpPath)
                              .then(function (data) {
                                  conflicts = data.conflicts;
                                  newmanifest = data.manifest;
                                  return Promise.resolve(true);
                              });
                      }
                  })
                  .then(function () {
                      return mythis.clearTempDir();
                  })
                  .then(function () {
                      var promises = mythis.checkProjectContainers([newmanifest]);

                      return Promise.all(promises);
                  })
                  .then(function() {
                      var list = mythis.projectlist;
                      var meta = _.cloneDeep(App.projectsManager.updateManifestToMeta(newmanifest));
                      var newlist = list.filter(function (item) {
                          return item.unique_id !== meta.unique_id;
                      });

                      newlist.push(App.projectsManager.updateManifestToMeta(newmanifest));

                      return mythis.sortProjects(newlist);
                  })
                  .then(function () {
                      mythis.showConflictsMessage("Import Complete", "Your project has been successfully imported.", conflicts);
                  })
                  .catch(function(err) {
                      mythis.showErrorMessage("Import Failed", "An error occurred while importing your project", err && err.error ? err.error : err);

                      return mythis.clearTempDir();
                  });
          }, 500);
      },

      clearTempDir: function () {
          return App.utils.fs.remove(App.configurator.getValue('tempDir'));
      },

      startUsfmImport: function () {
          var mythis = this;
          var path = require('path');
          var defaultPath = App.configurator.getUserPath('datalocation', 'backups');
          var filePath = App.ipc.sendSync('open-file', {options: {defaultPath: defaultPath, filters: [{name: 'USFM Files', extensions: ['txt', 'usfm']}], properties: ['openFile']}});
          if (!filePath) {
              return;
          }

          mythis.$.import.close();

          // TODO: do we need to create the temp dir??
          return App.importManager.retrieveUSFMProjectID(filePath[0])
              .then(function (id) {
                  var name = "";
                  if (id) {
                      var data = App.dataManager.getProjectName(id);
                      if (data) {
                          name = data;
                      } else {
                          id = "";
                      }
                  }
                  mythis.set('importdata', {importing: true, filepath: filePath[0], project: {slug: id, name: name}});
                  mythis.set('route', 'new');
              }).catch(function (err) {
                  var filename = (filePath && filePath[0]) || '';
                  mythis.showErrorMessage('Import Failed', 'Error occurred reading file: ' + filename, err);
                  return mythis.clearTempDir();
              });
      },

      confirmUsfmImport: function() {
          var mythis = this;
          var projectmeta = this.importdata.projectmeta;
          const targetDir = App.configurator.getValue('targetTranslationsDir');
          const paths = App.projectsManager.makeProjectPaths(targetDir, projectmeta);

          setTimeout(function() {
              return App.utils.fs.stat(paths.projectDir).then(function() {
                  // project exists
                  mythis.$.confirmimportusfm.open();
              }).catch(function() {
                  mythis.finishUsfmImport();
              });
          }, 500);

      },

      finishUsfmImport: function () {
          var mythis = this;
          var user = this.currentuser;
          var tmpDir = App.configurator.getValue('tempDir');
          var filepath = this.importdata.filepath;
          var projectmeta = this.importdata.projectmeta;
          var overwrite = this.importdata.overwrite;
          var timeString = App.utils.getTimeStamp();
          var backupName = projectmeta.unique_id + '.' + timeString + '.tstudio';
          var backupPath = App.configurator.getUserPath('datalocation', 'backups', backupName);

          mythis.showLoadingMessage('Importing.  Please wait...');

          setTimeout(function() {
              return Promise.resolve(true)
                  .then(function () {
                      if (overwrite) {
                          return App.exportManager.backupTranslation(projectmeta, backupPath);
                      } else {
                          return Promise.resolve(true);
                      }
                  })
                  .then(function () {
                      return App.importManager.importFromUSFM(filepath, projectmeta);
                  })
                  .then(function (chunks) {
                      if(overwrite) {
                          return App.projectsManager.createTargetTranslation(chunks, projectmeta, user);
                      } else {
                          return App.projectsManager.createTargetTranslation(chunks, projectmeta, user, tmpDir).then(function(tempProjectDir) {
                              const targetDir = App.configurator.getValue('targetTranslationsDir');
                              const paths = App.projectsManager.makeProjectPaths(targetDir, projectmeta);
                              // TODO: the language code seems to be broken in Amarenga y'Inkinyarwanda.
                              // TODO: merge with existing project
                              return App.gitManager.merge(user, paths.projectDir, tempProjectDir);
                          });
                      }
                  })
                  .then(function () {
                      var list = mythis.projectlist;
                      var meta = _.cloneDeep(projectmeta);
                      var newlist = list.filter(function (item) {
                          return item.unique_id !== meta.unique_id;
                      });

                      newlist.push(App.projectsManager.updateManifestToMeta(meta));

                      return mythis.sortProjects(newlist);
                  })
                  .then(function () {
                      mythis.showMessage('Import Complete', 'Your file has been imported. Please review it carefully. If it was not formatted properly, text may not appear as desired.');
                      return mythis.clearTempDir();
                  })
                  .catch(function (err) {
                      mythis.showErrorMessage('Import Failed', 'Error occurred importing project', err);

                      if (overwrite) {
                          return App.importManager.extractBackup(backupPath)
                              .then(function (list) {
                                  return Promise.all(list.map(function (item) {
                                      return App.utils.fs.mover(item.tmpPath, item.targetPath);
                                  }))
                              })
                              .then(function () {
                                  return mythis.clearTempDir();
                              })
                              .catch(function () {
                                  return mythis.clearTempDir();
                              });
                      } else {
                          return mythis.clearTempDir();
                      }
                  });
          }, 500);
      },

      startContainerImport: function () {
          var mythis = this;
          var defaultPath = App.configurator.getUserPath('datalocation', 'backups');
          var filePath = App.ipc.sendSync('open-file', {options: {defaultPath: defaultPath, properties: ['openDirectory']}});
          if (!filePath) {
              return;
          }

          mythis.set('importdata', {filepath: filePath[0]});
          mythis.$.import.close();
          mythis.showLoadingMessage('Importing source text. Please wait...');

          setTimeout(function() {
              return App.dataManager.checkForContainer(filePath[0])
                  .then(function(exists) {
                      if (exists) {
                          mythis.closeLoading();
                          mythis.$.containerconfirm.open();
                      } else {
                          return mythis.finishContainerImport();
                      }
                  });
          }, 500);
      },

      finishContainerImport: function () {
          var mythis = this;
          var filePath = this.importdata.filepath;

          mythis.showLoadingMessage('Importing source text. Please wait...');

          setTimeout(function() {
              return App.dataManager.importContainer(filePath)
                  .then(function() {
                      mythis.showMessage('Import Complete', 'Your source text has been successfully imported.');
                  })
                  .catch(function(err) {
                      var errmessage = 'An error occurred while importing your source text.';

                      if (err.toString()) {
                          errmessage = err.toString();
                      }
                      mythis.showErrorMessage('Import Failed', errmessage, err);
                  });
          }, 500);
      },

      openExport: function () {
          this.$.export.open();
      },

      uploadProject: function () {
          var mythis = this;
          var projectmeta = this.currentproject.projectmeta;
          var loading = this.$.wideloading;
          var target = App.configurator.getValue('targetTranslationsDir');
          var paths = App.utils.makeProjectPaths(target, projectmeta);
          var repo = projectmeta.unique_id;
          var user = this.currentuser;
          var shell = require('electron').shell;
          var deviceId = "";

          mythis.$.export.close();
          mythis.set('options', {});
          mythis.set('options.body', "Uploading Project.  Please wait...");
          mythis.set('options.loading', true);
          loading.open();

          return App.gitManager.commitAll(user, paths.projectDir)
              .then(function () {
                  return App.utils.getDeviceId();
              })
              .then(function (devId) {
                  deviceId = devId;
                  var getreg = App.keyManager.getRegistrationInfo.bind(App.keyManager, deviceId),
                      genreg = App.keyManager.generateRegistrationInfo.bind(App.keyManager, deviceId),
                      rereg = function () {
                          return App.userManager.unregister(user, deviceId).then(genreg);
                      };

                  return getreg().catch(rereg);
              })
              .then(function (reg) {
                  user.reg = reg;
                  return App.userManager.register(user, deviceId);
              })
              .then(function () {
                  return App.userManager.createRepo(user, repo);
              })
              .then(function (repo) {
                  return App.gitManager.push(user, paths.projectDir, repo).then(App.utils.ret(repo.full_name));
              })
              .then(function (fullname) {
                  var url = "https://door43.org/u/" + fullname;

                  mythis.set('options.title', "Upload Complete");
                  mythis.set('options.body', "Your project has been uploaded to:");
                  mythis.set('options.link', url);
                  mythis.set('options.showlink', true);
                  mythis.set('options.loading', false);
                  var link = loading.getElementsByClassName("url");
                  link[0].addEventListener('click', function clicker (event) {
                      event.preventDefault();
                      shell.openExternal(url);
                      link[0].removeEventListener('click', clicker);
                  });
              })
              .catch(function (err) {
                  err = err || '';
                  var errmessage = "";

                  if (err.syscall === "getaddrinfo") {
                      errmessage = "Unable to connect to server";
                  } else if (err.status === 401) {
                      errmessage = "Cannot upload without connecting to a Door43 account.";
                  } else {
                      errmessage = err.data || err.stderr || "An error occurred while trying to upload your project.";
                  }

                  if (typeof errmessage === 'string' && errmessage.includes("rejected because the remote contains work")) {
                      loading.close();
                      mythis.$.conflict.open();
                  } else {
                      mythis.showErrorMessage('Upload Failed', errmessage, err);
                  }
              });
      },

      exportProject: function () {
          var mythis = this;
          var projectmeta = this.currentproject.projectmeta;
          var defaultPath = App.configurator.getUserPath('datalocation', 'backups', projectmeta.unique_id);
          var filePath = App.ipc.sendSync('save-as', {options: {defaultPath: defaultPath, filters: [{name: 'Tstudio Files', extensions: ['tstudio']}]}});
          if (!filePath) {
              return;
          }

          mythis.$.export.close();
          mythis.showLoadingMessage('Creating Project File.  Please wait...');

          setTimeout(function() {
              return App.exportManager.backupTranslation(projectmeta, filePath)
                  .then(function () {
                      mythis.showMessage('Project File Complete', 'Your project has been successfully saved.');
                  })
                  .catch(function (err) {
                      mythis.showErrorMessage('File Failed', 'An error occurred while trying to save your project', err);
                  });
          }, 500);
      },

      checkPrint: function () {
          var projectmeta = this.currentproject.projectmeta;

          this.$.export.close();

          if (this.route === "home") {
              this.fire('iron-signal', {name: 'loadproject', data: {projectmeta: projectmeta, nav: "print"}});
          } else {
              this.openPrint();
          }
      },

      openPrint: function () {
          this.$.print.open();
          this.$.printoptions.reset();
      },

      openPreview: function () {
          var mythis = this;
          var options = _.cloneDeep(this.options);
          var current = this.route;

          mythis.$.print.close();
          mythis.showLoadingMessage("Preparing to Print. Please wait...");
          if (current === "translate") {
              mythis.fire('iron-signal', {name: 'translateleft'});
          }
          if (current === "review") {
              mythis.fire('iron-signal', {name: 'reviewleft'});
          }

          setTimeout(function() {
              return Promise.resolve(true)
                  .then(function () {
                      if (options.includeImages) {
                          mythis.set('options.body', "Downloading Images. Please wait...");
                          var forceDownload = App.configurator.getUserSetting("resetimages");
                          App.configurator.setUserSetting("resetimages", false);
                          return App.printManager.downloadImages(forceDownload)
                              .then(function(){
                                  mythis.set('options.body', "Extracting Images. Please wait...");
                                  return App.printManager.extractImages();
                              });
                      } else {
                          return Promise.resolve(true);
                      }
                  })
                  .then(function () {
                      mythis.set('options.body', "Creating print preview. Please wait...");
                      setTimeout(function() {
                          mythis.set('currentproject.printoptions', options);
                          mythis.$.preview.rendertext();
                          mythis.closeLoading();
                          App.configurator.setValue("backto", current);
                          mythis.set('route', 'preview');
                      }, 500);
                  })
                  .catch(function(err){
                      var errmessage = "An error occurred while downloading images";
                      if(err !== null) {
                          errmessage = err;
                      }
                      mythis.showErrorMessage("Download Failed", errmessage, err);
                  });
          }, 500);
      },

      checkUsfm: function () {
          var projectmeta = this.currentproject.projectmeta;

          this.$.export.close();

          if (this.route === "home") {
              this.fire('iron-signal', {name: 'loadproject', data: {projectmeta: projectmeta, nav: "export"}});
          } else {
              this.exportUsfm();
          }
      },

      exportUsfm: function () {
          var mythis = this;
          var projectmeta = this.currentproject.projectmeta;
          var translation = this.currentproject.chunks;
          var conflicts = this.currentproject.conflicts;
          var mediaServer = App.configurator.getUserSetting("mediaserver");
          var name = projectmeta.unique_id;
          var defaultPath = App.configurator.getUserPath('datalocation', name);
          var filePath;

          if (conflicts) {
              mythis.showMessage("Conflicts Exist", "You must resolve all conflicts before exporting to USFM.");
              return;
          }

          if (projectmeta.format === 'markdown') {
              filePath = App.ipc.sendSync('save-as', {options: {defaultPath: defaultPath, filters: [{name: 'Zip Files', extensions: ['zip']}]}});
          } else {
              filePath = App.ipc.sendSync('save-as', {options: {defaultPath: defaultPath, filters: [{name: 'USFM Files', extensions: ['usfm']}]}});
          }
          if (!filePath) {
              return;
          }

          mythis.showLoadingMessage("Exporting Project.  Please wait...");

          setTimeout(function() {
              return App.exportManager.exportTranslation(translation, projectmeta, filePath, mediaServer)
                  .then(function () {
                      mythis.showMessage("Project Exported", "Your project has been successfully exported to a file.");
                  })
                  .catch(function (err) {
                      var errmessage = "An error occurred while trying to export your project";
                      if(err !== null) {
                          errmessage = err;
                      }
                      mythis.showErrorMessage("Export Failed", errmessage, err);
                  });
          }, 500);
      },

      openFeedback: function () {
          this.set('feedback', '');
          this.$.feedback.open();
      },

      closeFeedback: function () {
          this.$.feedback.close();
          this.set('feedback', '');
          this.set('feedbackEmail', '');
          this.set('feedbackIncludeLogs', true);
      },

      sendFeedback: function () {
          var message = this.feedback;
          var email = this.feedbackEmail;
          var includeLogs = this.feedbackIncludeLogs;
          var helpdeskEmail = App.configurator.getUserSetting('helpdeskemail');
          var helpdeskToken = App.configurator.getValue('helpdesk-token');
          var mythis = this;

          mythis.closeFeedback();

          mythis.showLoadingMessage("Sending Feedback. Please wait...");

          if(!email && this.currentuser.email && this.currentuser.email.indexOf('noreply.door43.org') === -1) {
              // use user's account email
              email = this.currentuser.email;
          }

          if(!helpdeskToken) {
              mythis.showErrorMessage('Feedback Failed', 'You are not set up with a token to send feedback.', null);
              return;
          }

          if(!helpdeskEmail) {
              mythis.showErrorMessage('Feedback Failed', 'Feedback recipient email is invalid. Please check your settings.', null);
              return;
          }

          App.submitFeedback({
              category: "General Feedback",
              message: message,
              name: this.currentuser.full_name,
              email: email,
              state: includeLogs ? {} : null,
              helpdeskToken: helpdeskToken,
              helpdeskEmail: helpdeskEmail
          }).then(function() {
              mythis.showMessage('Feedback Sent', 'Your feedback has been successfully sent.');
          }).catch(function(e) {
              if(e.message === 'Network Error') {
                  mythis.showErrorMessage('Feedback Failed', 'Please check your internet connection and try again.', e);
              } else {
                  mythis.showErrorMessage('Feedback Failed', 'An error occurred while sending feedback', e);
              }
          });
      },

      updateFromProject: function () {
          var mythis = this;
          var translate = this.$.translate;

          return Promise.resolve(true)
              .then(function () {
                  var list = mythis.projectlist;
                  var meta = _.cloneDeep(mythis.currentproject.projectmeta);
                  var newlist = list.filter(function (item) {
                      return item.unique_id !== meta.unique_id;
                  });

                  newlist.push(App.projectsManager.updateManifestToMeta(meta));

                  return mythis.sortProjects(newlist);
              })
              .then(function () {
                  mythis.set('route', "home");
                  translate.reset();
                  return Promise.resolve(true);
              })
              .then(function () {
                  mythis.closeLoading();
              });
      },

      sortProjects: function (list) {
          var mythis = this;
          var sorted = App.projectsManager.sortProjectList(list);

          return Promise.resolve(true)
              .then(function () {
                  mythis.set('projectlist', sorted);
                  return Promise.resolve(sorted);
              });
      },

      checkProjectContainers: function (list) {
          var promises = [];
          var strings = {};

          for (var i = 0; i < list.length; i++) {
              var proj = list[i].project.id;

              for (var j = 0; j < list[i].source_translations.length; j++) {
                  var lang = list[i].source_translations[j].language_id;
                  var res = list[i].source_translations[j].resource_id;
                  var string = lang + "_" + proj + "_" + res;
                  if (!strings[string]) {
                      strings[string] = true;
                      var open = App.dataManager.activateProjectContainers(lang, proj, res);
                      promises.push(open);
                  }
              }
          }

          return promises;
      },

      checkAllContainers: function (list) {
          var promises = this.checkProjectContainers(list);

          promises.push(App.dataManager.activateContainer('en', 'bible', 'tw'));
          promises.push(App.dataManager.activateContainer('en', 'bible-obs', 'tw'));
          promises.push(App.dataManager.activateContainer('en', 'ta-audio', 'vol2'));
          promises.push(App.dataManager.activateContainer('en', 'ta-checking', 'vol1'));
          promises.push(App.dataManager.activateContainer('en', 'ta-checking', 'vol2'));
          promises.push(App.dataManager.activateContainer('en', 'ta-gateway', 'vol3'));
          promises.push(App.dataManager.activateContainer('en', 'ta-intro', 'vol1'));
          promises.push(App.dataManager.activateContainer('en', 'ta-process', 'vol1'));
          promises.push(App.dataManager.activateContainer('en', 'ta-translate', 'vol1'));
          promises.push(App.dataManager.activateContainer('en', 'ta-translate', 'vol2'));

          return Promise.all(promises)
              .then(function () {
                  return list;
              });
      },

      checkBuild: function () {
          var mythis = this;
          var path = require('path');
          var libraryDir = App.configurator.getValue('libraryDir');
          var libraryPath = path.join(libraryDir, "index.sqlite");
          var srcDir = path.resolve(path.join(__dirname, '..'));
          var srcDB = path.join(srcDir, 'index', 'index.sqlite');
          var appData = App.configurator.getAppData();
          var libraryBuild = App.configurator.getValue("libraryBuild");
          var tmpDir = App.configurator.getValue('tempDir');
          var resourceDir = App.dataManager.getResourceDir();
          var movePromises = Promise.resolve(true);

          if (!libraryBuild) {
              App.configurator.setUserSetting("bemode", false);
          }

          if (libraryBuild != appData.build) {
              var translations = [];

              App.ipc.send('loading-status', 'Updating Index File...');

              if (parseInt(libraryBuild) >= 110) {
                  translations = App.dataManager.getTranslations();
              }

              var imports = translations.filter(function (item) {
                  return item.resource.imported;
              });

              imports.forEach(function (item) {
                  var foldername = item.language.slug + "_" + item.project.slug + "_" + item.resource.slug;
                  var tmpPath = path.join(tmpDir, foldername);
                  var resourcePath = path.join(resourceDir, foldername);

                  movePromises = movePromises.then(function () {
                      return App.utils.fs.mover(resourcePath, tmpPath);
                  });
              });

              return movePromises
                  .then(function () {
                      return App.utils.fs.readFile(srcDB);
                  })
                  .then(function (content) {
                      return App.utils.fs.writeFile(libraryPath, content);
                  })
                  .then(function () {
                      App.configurator.setValue("libraryBuild", appData.build);
                      if (imports.length) {
                          return App.utils.fs.readdir(tmpDir);
                      }
                      return [];
                  })
                  .then(function (temps) {
                      var importPromises = Promise.resolve(true);

                      temps.forEach(function (item) {
                          var itemPath = path.join(tmpDir, item);

                          importPromises = importPromises.then(function () {
                              return App.dataManager.importContainer(itemPath);
                          });
                      });

                      return importPromises;
                  })
                  .then(function () {
                      return mythis.clearTempDir();
                  })
                  .catch(function (e) {
                      return mythis.clearTempDir();
                  })
                  .then(function () {
                      App.ipc.send('loading-status', 'Migrating Projects...');
                      return App.projectsManager.migrateTargetTranslationsList();
                  })
                  .then(function () {
                      return Promise.resolve(true);
                  });
          } else {
              return Promise.resolve(false);
          }
      },

      createInitialSettings: function (version) {
          var untildify = require('untildify');
          var gitversion = version ? version.toString() : 'N/A';

          App.configurator.refreshUserSetting();
          App.configurator.setUserSetting('gitversion', gitversion);
          App.configurator.setUserSetting('appversion', App.configurator.getAppData().toString());
          App.configurator.setUserSetting('datapath', App.configurator.getValue('rootdir'));

          var location = App.configurator.getUserSetting('datalocation');

          location = untildify(location);
          location = location.replace(/\\/g, "\/");
          App.configurator.setUserSetting('datalocation', location);
          App.configurator.applyPrefAppearance();
      },

      ready: function() {
          var mythis = this;

          return App.gitManager.verifyGit()
              .then(function (version) {
                  App.ipc.send('loading-status', 'Retrieving User Settings...');
                  App.reporter.logNotice('Git Version ' + version);
                  mythis.createInitialSettings(version);
                  mythis.checkUser(App.configurator.getValue("userdata"));

                  return mythis.checkBuild();
              })
              .then(function (updates) {
                  if (updates) {
                      App.ipc.send('fire-reload');
                      return Promise.resolve(false);
                  } else {
                      App.ipc.send('loading-status', 'Retrieving Project List...');
                      return App.projectsManager.loadTargetTranslationsList()
                          .then(function (list) {
                              App.ipc.send('loading-status', 'Opening resource containers...');
                              return mythis.checkAllContainers(list);
                          })
                          .then(function (list) {
                              App.ipc.send('loading-status', 'Updating Project List...');
                              return _.compact(list.map(App.projectsManager.updateManifestToMeta, App.projectsManager));
                          })
                          .then(function (list) {
                              return mythis.sortProjects(list);
                          })
                          .then(function (list) {
                              App.ipc.send('loading-status', 'Creating Auto Backups...');
                              return App.exportManager.backupAllTranslations(list);
                          })
                          .then(function () {
                              App.ipc.send('main-loading-done');
                              mythis.$.home.setsortfields();
                          });
                  }
              })
              .catch(function (err) {
                  var msg = 'Something broke.';
                  err && err.stack && App.reporter.logError(err.stack, 'Error on startup');

                  if (err && typeof err === 'string') {
                      msg = err;
                  } else if (err && err.toString() !== '[object Object]') {
                      msg = err.toString();
                  }

                  mythis.showErrorMessage('Error on startup', msg, err);
                  App.ipc.send('main-loading-done');
                  mythis.$.home.setsortfields();
              });
      }

  });

</script>
